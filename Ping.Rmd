---
title: "Final Team Project" 
author: "Abizer, Matthew, Ping, Rosy"
date: "12/15/2022"
output: 
  github_document:
    pandoc_args: --webtex
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(collapse=TRUE, prompt=TRUE,comment=NULL,message=FALSE, echo = FALSE, include=TRUE, fig.width = 9, fig.height = 4) #This code chunk ensures that there are no commands in output file.
```

```{r packageCheck, include=FALSE}
mypacks <- c("ggplot2","dplyr","readr","tidyr", "ROCR", "boot","class","randomForest","e1071", "stringr","partykit","rpart","plyr","pracma","leaflet", "maps", "rgdal", "rgeos","leaflet", "tree","doParallel","foreach", "ggmap","geosphere")  # what packages are needed?
packs <- installed.packages()   # find installed package list
install.me <- mypacks[!(mypacks %in% packs[,"Package"])]  #what needs to be installed?
if (length(install.me) >= 1) install.packages(install.me, repos = "http://cran.us.r-project.org")   # install (if needed)
lapply(mypacks, library, character.only=TRUE)  # load all packages
```
In our final project, we want to predict Uber fares in New York State using the dataset below which we found on Kaggle. 

```{r}
uber_fare <- uber
```

We first cleaned the data. Our original dataset had a column - pickup_datetime - which stored the date and time of pickup. We chose to break down this variable into separate columns that extracted the pickup time, year, date and month. We then filtered the latitude and longitude co-ordinates to fit those of New York state. We also included a time category column that categorized the pickup times into morning, afternoon and night. Finally, we created a distance variable that computes the distance between the latitudes and longitudes of the pickup and dropoff locations. 

```{r}
Q1_f <- quantile(uber_fare$fare_amount, .33) #compute 33% of data
Q2_f <- quantile(uber_fare$fare_amount, .66) #compute 66% of data
```

```{r}
uber_fare_mod <- uber_fare %>% mutate(pickup_time = str_extract(pickup_datetime,"[\\d]{1,2}:[\\d]{2}"), pickup_year = str_extract(pickup_datetime,"[\\d]{4}"), pickup_month_dash = str_extract(pickup_datetime, "-{1}[\\d]{2}-{1}"), pickup_month = str_extract(pickup_month_dash, "[\\d]{2}"), pickup_date_dash = str_extract(pickup_datetime, "-[\\d]{2}"), pickup_date = str_extract(pickup_date_dash, "[\\d]{2}"), pickup_longitude_mod = ifelse(pickup_longitude < -79.4554 | pickup_longitude > -71.4725, NA, pickup_longitude), pickup_latitude_mod = ifelse(pickup_latitude < 40.29400 | pickup_latitude > 45.00420, NA, pickup_latitude), dropoff_longitude_mod = ifelse(dropoff_longitude < -79.4554 | dropoff_longitude > -71.4725, NA, dropoff_longitude), dropoff_latitude_mod = ifelse(dropoff_latitude < 40.29400 | dropoff_latitude > 45.00420, NA, dropoff_latitude), time_category = case_when(
    pickup_time >= "0:01" & pickup_time < "12:00" ~ "morning",
    pickup_time >= "12:01" & pickup_time < "18:00" ~ "afternoon",
    pickup_time >= "18:01" & pickup_time < "24:00" ~ "evening")) %>% na.omit()
                                      
#time_range = ifelse(pickup_time < 12:00, "Morning", "Afternoon"), time_category = ifelse(pickup_time > 18:00, "Night", time_range ) ) %>% na.omit()
# cleaned the data to add a separate column for pickup_year, pickup_month, pickup_date. Filtered the latitude and longitude coordinates to include those of New York State. Added a time category column which separates the day into morning, evening and night
```

```{r}
uber_fare_mod <- filter_if(uber_fare_mod, is.numeric, all_vars((.) != 0)) %>% select(fare_amount, passenger_count, pickup_time, pickup_year, pickup_month, pickup_date, pickup_longitude_mod, pickup_latitude_mod, dropoff_longitude_mod, dropoff_latitude_mod, time_category)
#created a new dataframe that only includes the variables that we want in our project from the bigger dataframe

```

```{r}
library(pracma)

dist_conversion <- function(lat1,lat2,lon1,lon2){
    lon1 = deg2rad(lon1)
    lon2 = deg2rad(lon2)
    lat1 = deg2rad(lat1)
    lat2 = deg2rad(lat2)
      
    # Haversine formula
    dlon = lon2 - lon1
    dlat = lat2 - lat1
    a = sin(dlat / 2)**2 + cos(lat1) * cos(lat2) * sin(dlon / 2)**2
 
    c = 2 * asin(sqrt(a))
    
    # Radius of earth in kilometers. Use 3956 for miles
    r = 3956
      
    # calculate the result
    return(c * r)
}
#function to transform latitude and longitude coordinates into distances [https://www.geeksforgeeks.org/haversine-formula-to-find-distance-between-two-points-on-a-sphere/]
```

```{r}
uber_dist <- uber_fare_mod %>% mutate(distance = dist_conversion(pickup_latitude_mod,dropoff_latitude_mod, pickup_longitude_mod, dropoff_longitude_mod)) %>% filter(distance > 0, fare_amount>7.19)
# added the distance variable into our dataframe
```

```{r}
uber_dist %>% select(distance, fare_amount) %>% gather(key = variable, value = value, distance:fare_amount) %>% ggplot(aes(x = variable, y = value)) + geom_boxplot() + facet_wrap(~variable, scales="free")+ ggtitle("Boxplots of Distance & Fare_amount") # drew a boxplot of distances and fare amounts in boxplot

#filter out distance outliers
Q1 <- quantile(uber_dist$distance, .25)
Q3 <- quantile(uber_dist$distance, .75)
IQR <- IQR(uber_dist$distance)


uber_dist_cleaner <- uber_dist %>% filter(distance < 6.306145 & distance > -1.57)

#filter out fare_amount outliers
Q1_f <- quantile(uber_dist$fare_amount, .25)
Q3_f <- quantile(uber_dist$fare_amount, .75)
IQR_f <- IQR(uber_dist$fare_amount)

uber_dist_cleaner <- uber_dist_cleaner %>% filter(fare_amount > -1.9 & fare_amount < 26.9)
```

```{r eval = "FALSE"}
k<- 1:10

#cluster for pickup
set.seed(11)

total.Wss.pickup <- sapply(k, function(x) kmeans(uber_dist_cleaner[,7:8], centers=x, nstart=20)$tot.withinss)

ggplot(data_frame(total.Wss.pickup, k), aes(x=k,y=total.Wss.pickup)) + geom_point() + geom_line() + scale_x_continuous(breaks=1:10)

#graphed total within cluster variation against k to compute optimal k
```
```{r}
#cluster for dropoff
k<- 1:10

set.seed(11)

total.Wss.dropoff <- sapply(k, function(x) kmeans(uber_dist_cleaner[,9:10], centers=x, nstart=20)$tot.withinss)

ggplot(data_frame(total.Wss.dropoff, k), aes(x=k,y=total.Wss.dropoff)) + geom_point() + geom_line() + scale_x_continuous(breaks=1:10)
```

```{r}
set.seed(7)
km_out_pickup <- kmeans(uber_dist_cleaner[,7:8], centers = 4, nstart = 20) #ran the k-means model to create 4 clusters of data using 20 random starting points
uber_dist_cleaner <- uber_dist_cleaner %>% mutate(cluster_pickup = as.character(km_out_pickup$cluster))
#cluster group for pickup

km_out_dropoff <- kmeans(uber_dist_cleaner[,9:10], centers = 4, nstart = 20) #ran the k-means model to create 4 clusters of data using 20 random starting points
uber_dist_cleaner <- uber_dist_cleaner %>% mutate(cluster_dropoff = as.character(km_out_dropoff$cluster))
#Cluster group for dropff
```



```{r}
uber_dist_2015 <- uber_dist_cleaner %>% filter(pickup_year=="2015")
uber_dist_2014 <- uber_dist_cleaner %>% filter(pickup_year=="2014")
uber_dist_2015 %>% group_by(cluster_dropoff) %>% dplyr::summarize(n = n()) #summary results of number of data points in each cluster
uber_dist_2015 %>% group_by(cluster_pickup) %>% dplyr::summarize(n = n())
#Create 2015 and 2014 data for analysis
```


```{r}
library(ggmap)

#Create maps to visualize clustering for pickup and dropoff
register_google(key = "AIzaSyB-C3liKGZzMpScV_lEwVlpY94-FB-NUtg", write = TRUE)

base_map_pickup <- ggmap(get_googlemap(center = c(-73.958285, 40.713000), zoom = 10))

base_map_pickup + geom_point(data = uber_dist_2015, aes(x = pickup_longitude_mod, y = pickup_latitude_mod, color=cluster_pickup),size = 1) 

base_map_dropoff <- ggmap(get_googlemap(center = c(-73.908285, 40.713000), zoom = 10))

base_map_dropoff + geom_point(data = uber_dist_2015, aes(x = dropoff_longitude_mod, y = dropoff_latitude_mod, color = cluster_dropoff), size = 1)
```
```{r}
#plot where the uber rides are going depending on pickup cluster (represented by black)

base_map_path<- ggmap(get_googlemap(center = c(-73.958285, 40.723000), zoom = 10))


start_point <- uber_dist_2015[, c("pickup_longitude_mod", "pickup_latitude_mod")]
end_point <- uber_dist_2015[, c("dropoff_longitude_mod", "dropoff_latitude_mod")]
base_map_path + 
  geom_point(data = uber_dist_2015, aes(x = dropoff_longitude_mod, y = dropoff_latitude_mod, color= cluster_dropoff), size = 2, alpha = 1) +
    geom_point(data = uber_dist_2015, aes(x = pickup_longitude_mod, y = pickup_latitude_mod), size = 1, alpha = 0.5) + facet_wrap(~cluster_pickup)
  
```
```{r}
#look at which clusters are largest
uber_dist_2015 %>% group_by(cluster_pickup) %>% dplyr::summarize(n = n())

```
```{r}
library(units)
#calculate direction of uber ride in degrees
uber_dist_2015$direction <- atan2(sin( uber_dist_2015$dropoff_longitude_mod - uber_dist_2015$pickup_longitude_mod), 
                           cos( uber_dist_2015$dropoff_latitude_mod - uber_dist_2015$pickup_latitude_mod ))

uber_dist_2015$direction <- uber_dist_2015$direction * (180 / pi)

uber_dist_2014$direction <- atan2(sin( uber_dist_2014$dropoff_longitude_mod - uber_dist_2014$pickup_longitude_mod), 
                           cos( uber_dist_2014$dropoff_latitude_mod - uber_dist_2014$pickup_latitude_mod ))

uber_dist_2014$direction <- uber_dist_2014$direction * (180 / pi)
```

```{r}
#visualize whether direction impacts fare amount using a scatter plot
ggplot(data = uber_dist_2015, aes(x = pickup_latitude_mod - dropoff_latitude_mod, y = pickup_longitude_mod - dropoff_longitude_mod)) + geom_point(aes(color=fare_amount)) +  scale_color_continuous() + labs(x="Delta Latitude", y="Delta Longitude") + geom_smooth(method="lm", color="red")

```

```{r}
#determining distribution of uber ride distances

ggplot(data=uber_dist_2015, aes(x=distance)) + geom_histogram() +  scale_x_continuous()

#most rides are short rides < 2 miles
```
```{r}
#after creating a scatter plot of the fare amount and distance, facet wrapped based on time category, we can see that there is a linear relationship between those 2 variables. The horizontal lines on the scatter plot may represent fixed prices for specific locations in New York. 
ggplot(data=uber_dist_2015, aes(x=distance, y = fare_amount)) + geom_point() + facet_wrap(~time_category) + geom_smooth(method = "lm")

```
```{r}
# determine distribution of passenger counts
passenger_counts <- uber_dist_2015 %>% group_by(passenger_count) %>% dplyr::summarize(n = n())
passenger_counts <- uber_dist_2014 %>% group_by(passenger_count) %>% dplyr::summarize(n = n())
```

```{r}
#random forest on new predictors (training)
set.seed(1231)
rf <- randomForest(fare_amount ~ pickup_latitude_mod+pickup_longitude_mod+ dropoff_latitude_mod+ dropoff_longitude_mod+ pickup_time+distance+direction, data=uber_dist_2015, ntree = 250, mtry=7)
plot(rf)
rf
importance(rf)
uber_dist_2015 <- uber_dist_2015 %>% mutate(prediction = round(predict(rf, type = "response"),0)) 
```
```{r}
#random forest on 2014 data (test)
#uber_dist_2014 <- sample_frac(uber_dist_2014, 0.45438028728779878498836086981207) # run this line of code once so 2014 and 2015 data sets are the same size, then delete it

uber_dist_2014 <- uber_dist_2014 %>% mutate(pred_2014 = round(predict(rf, type = "response"),0))
```

```{r}
#graph our predicted fare prices against actual fare prices using facet wrap for time categories
ggplot(data=uber_dist_2015, aes(x=fare_amount, y = prediction)) + geom_point() + facet_wrap(~time_category) + geom_smooth(method = "lm")

```




